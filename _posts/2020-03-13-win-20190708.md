---
layout: post
title:  "CVE-2019-0708"
categories: windows
tags: windows kernel
author: ble55ing
---

## CVE-2019-0708

这个漏洞是RDP数据连接通信过程中产生的UAF漏洞

RDP建立连接时，RDP Server 默认调用IcaCreateChannel()创建MS_T120静态虚拟信道，并绑定到信道0x1F，然后RDP Client 还可以在信道连接阶段让RDPServer 绑定名称为“MS_T120”的信道 ，在IcaReBindVirtualChannels函数中。然后就会搜索MS_T120信道，将该信道绑定到用户指定的信道号上。之后Client介意断开第二次绑定的信道，然后再断开RDP连接时

### RDP，远程桌面协议 

3389端口，是一个多通道的协议，该协议通过SVC（静态虚拟通道） 在传递图像、鼠标键盘等的重定向。在RDP连接的第二个请求包中包含着需要申请的静态虚拟通道名称。 

MS_T120信道对象指针在RDP 连接创建的时候就会建立，并立即绑定到0x1F信道号中。 

### 补丁

如果单独把sys放ida里，会因为没有pdf所以显示不出好多东西，所以需要让其自动下载（VPS）

对比查看补丁，发现是在第二次申请绑定的时候，如果申请为MS_T120则强制绑定到0x1F

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/1221.png)

### 调试

刚进如系统绑定的通道为-1的“CTXTW  ”通道。。

当进行远程连接的一开始，会进入termdd的IcaBindVirtualChannels函数，然后就会建立MS_T120的连接，并绑定在0x1f上

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200312220406.png)

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/zx.png)

接下来我们发送rdp的申请，其中包含要申请的通道的名称

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200312220550.png)

但之后我们还可以再申请一个MS_T120的通道，这样就有了两个通道，然后我们把自己申请的通道释放掉，就造成了一个UAF。

这里可以看到，新申请的MS_T120以4的通道号又绑定了一次

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200312220854.png)

可以看到我们freeMS_T120的channel

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200312225503.png)

在第二次调用_IcaFreeChannel时，在最后ExFreePoolWithTag时出错，会导致程序崩溃

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200312222830.png)

```
*** Fatal System Error: 0x00000050
                       (0x88C969C0,0x00000000,0xF77EE78B,0x00000000)

Driver at fault: 
***    termdd.sys - Address F77EE78B base at F77ED000, DateStamp 4802532c
```

## 后续利用

这个UAF的利用过程为中首先需要申请一些内存，得到释放的那块内存。可以通过再开启一个RDP连接绑定MS_T120通道，并通过这个通道发数据的方式来占用到这一内存。

可以发现，在free这块区域时，IcaFreeChannel() 函数会先将我们申请的这个块释放掉。

然后，我们再将这个块申请过来，构成UAF。

接下来需要其劫持控制流，需要找到一个能调用的位置。在IcaChannelInputInternal函数中可以发现一处对其中内容的调用，这个位置在偏移0x50的位置，能够进行控制流的跳转。但是需要满足V15为非0.

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200312213900.png)

调用的地址需要通过堆喷的方式来定位，需要跳转到用户态然后执行再getshell