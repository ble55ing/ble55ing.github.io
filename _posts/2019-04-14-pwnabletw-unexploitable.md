---
layout: post
title:  "pwnable.tw unexploitable"
categories: ctf
tags: pwnable
author: ble55ing
---

* content
{:toc}

## pwnable.tw unexploitable 分析

这题是和pwnable.kr差不多的一道题，主要区别在于没有给syscall。所以需要自己去找。

首先看一下保护

![](https://raw.githubusercontent.com/ble55ing/PicGo/master/20190414215212.png?token=AlMwaChMmSgjYv2UJenZVlpOa0A3g640ks5csztLwA%3D%3D)

只有read和sleep两个函数。

思路一是首先劫持堆栈到bss段，然后调用read函数将sleep的got表中地址改成syscall（直接找到\x0f\x05），将/bin/sh放入bss中，然后设置rax为59调用syscall可以调用execve了，结果这个方法本地打通了远程打不通，不知道是什么原因。应该是地址不一样，所以决定先用write泄露一下地址然后再定位syscall。

未完待续

没有续了，问题出在服务器程序把我的两次read当成一次了，间隔时间太短，sleep(0.1)挂了，sleep(3)ok

另一种方法是看别人的blog中有提到的，在劫持堆栈到bss段之后，可以先用syscall调用write泄露sleep地址，然后计算出/bin/sh\x00的地址，pop rdi，ret；地址和system地址，rax的值可以通过read函数的返回值来控制，也是一个很可行的思路。
